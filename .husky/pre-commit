#!/bin/bash

PKG_MGR=pnpm

# Define colors
red='\033[1;31m'
green='\033[1;32m'
yellow='\033[1;33m'
cyan='\033[1;36m'
blue='\033[1;34m'
magenta='\033[1;35m'
clear='\033[0m'

# Global counters for summary
TOTAL_CHECKS=3
PASSED_CHECKS=0
FAILED_CHECKS=0
WARNINGS=0

# Enhanced progress bar with better status indicators
progress_bar() {
  local pid=$1
  local status_file=$2
  local label="$3"
  local delay=0.1
  local spin=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
  local spin_idx=0
  local width=40
  local char="â–‡"
  local start_time=$(date +%s)

  while kill -0 $pid 2>/dev/null; do
    local elapsed=$(( $(date +%s) - start_time ))
    # More realistic progress estimation based on typical task duration
    local progress=$(( (elapsed * 100 / 30) > 95 ? 95 : (elapsed * 100 / 30) ))
    local chars=$((progress * width / 100))

    printf "${cyan}\r[%s] ${yellow}%s${clear} [" "${spin[$spin_idx]}" "$label"
    for ((i = 0; i < chars; i++)); do printf "${green}$char${clear}"; done
    for ((i = chars; i < width; i++)); do printf "${blue}Â·${clear}"; done
    printf "] %s%% (%ss)" "$progress" "$elapsed"
    sleep $delay
    ((spin_idx=(spin_idx + 1) % 10))
  done

  local elapsed_total=$(( $(date +%s) - start_time ))
  local exit_code=$(<"$status_file")

  if [ "$exit_code" -eq 0 ]; then
    printf "${green}\r[âœ“] %s [" "$label"
    for ((i = 0; i < width; i++)); do printf "$char"; done
    printf "] PASSED (%ss)${clear}\n"
    ((PASSED_CHECKS++))
  else
    printf "${red}\r[âœ—] %s [" "$label"
    for ((i = 0; i < width; i++)); do printf "â–ˆ"; done
    printf "] FAILED (%ss)${clear}\n"
    ((FAILED_CHECKS++))
  fi
}

# Function to analyze and categorize output
analyze_output() {
  local log_file="$1"
  local check_type="$2"
  
  if [ ! -f "$log_file" ]; then
    echo -e "${red}Log file not found: $log_file${clear}"
    return 1
  fi

  local line_count=$(wc -l < "$log_file")
  local error_count=0
  local warning_count=0
  
  case "$check_type" in
    "i18n")
      error_count=$(grep -i "error\|missing\|invalid" "$log_file" | wc -l)
      warning_count=$(grep -i "warning\|deprecated" "$log_file" | wc -l)
      ;;
    "types")
      error_count=$(grep -i "error\|TS[0-9]\+:" "$log_file" | wc -l)
      warning_count=$(grep -i "warning" "$log_file" | wc -l)
      ;;
    "lint")
      error_count=$(grep -i "error" "$log_file" | wc -l)
      warning_count=$(grep -i "warning" "$log_file" | wc -l)
      ;;
  esac

  if [ "$line_count" -eq 0 ]; then
    echo -e "  ${green}âœ¨ Clean output - no issues detected${clear}"
  elif [ "$error_count" -gt 0 ]; then
    echo -e "  ${red}ðŸš¨ ${error_count} error(s) found${clear}"
    if [ "$warning_count" -gt 0 ]; then
      echo -e "  ${yellow}âš ï¸  ${warning_count} warning(s) found${clear}"
      ((WARNINGS+=warning_count))
    fi
  elif [ "$warning_count" -gt 0 ]; then
    echo -e "  ${yellow}âš ï¸  ${warning_count} warning(s) found${clear}"
    ((WARNINGS+=warning_count))
  else
    echo -e "  ${blue}ðŸ“ ${line_count} lines of output (review recommended)${clear}"
  fi
}

# Enhanced output display with smart truncation
display_output() {
  local log_file="$1"
  local check_type="$2"
  local max_lines=20
  
  if [ ! -f "$log_file" ] || [ ! -s "$log_file" ]; then
    echo -e "  ${green}âœ¨ No output (clean run)${clear}"
    return 0
  fi

  local total_lines=$(wc -l < "$log_file")
  
  echo -e "  ${cyan}ðŸ“‹ Output Preview:${clear}"
  
  if [ "$total_lines" -le "$max_lines" ]; then
    # Show all lines if output is short
    sed 's/^/    /' "$log_file"
  else
    # Show first 10 and last 10 lines with separator
    echo -e "    ${blue}--- First 10 lines ---${clear}"
    head -10 "$log_file" | sed 's/^/    /'
    echo -e "    ${blue}--- ... ($((total_lines - 20)) lines omitted) ... ---${clear}"
    echo -e "    ${blue}--- Last 10 lines ---${clear}"
    tail -10 "$log_file" | sed 's/^/    /'
  fi
  
  if [ "$total_lines" -gt "$max_lines" ]; then
    echo -e "  ${yellow}ðŸ’¡ Full output available in: $log_file${clear}"
  fi
}

# Banner with timestamp
echo -e "
${green}
     _       _          _____           _ 
    | |_   _(_) ___ ___|  ___|   _  ___| |
 _  | | | | | |/ __/ _ \ |_ | | | |/ _ \ |
| |_| | |_| | | (_|  __/  _|| |_| |  __/ |
 \___/ \__,_|_|\___\___|_|   \__,_|\___|_|

${clear}
"

echo -e "Let's hope you are not ${red}DUMB${clear}!"
echo -e "${yellow}Using package manager: ${cyan}${PKG_MGR}${clear}"
echo -e "${blue}Started at: $(date)${clear}\n"

# Enhanced run function with better error handling and output analysis
run_with_progress() {
  local label="$1"
  local script="$2"
  local check_type="$3"
  local log="${script}_output.log"
  local status_file="${script}_status.tmp"
  local stderr_log="${script}_stderr.log"

  echo -e "${cyan}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${clear}"
  echo -e "${yellow}ðŸ”„ Starting: ${label}${clear}"
  
  # Check if the script exists in package.json
  if ! $PKG_MGR run --silent $script --help >/dev/null 2>&1; then
    echo -e "${red}âŒ Script '$script' not found in package.json${clear}"
    echo -e "${yellow}ðŸ’¡ Available scripts:${clear}"
    $PKG_MGR run 2>/dev/null | grep -E "^  [a-zA-Z]" | head -5
    ((FAILED_CHECKS++))
    return 1
  fi

  (
    # Capture both stdout and stderr separately
    $PKG_MGR run $script > "$log" 2> "$stderr_log"
    local cmd_exit=$?
    
    # Combine stderr into main log if there are errors
    if [ -s "$stderr_log" ]; then
      echo -e "\n--- STDERR ---" >> "$log"
      cat "$stderr_log" >> "$log"
    fi
    
    echo $cmd_exit > "$status_file"
  ) &
  
  local pid=$!
  progress_bar $pid "$status_file" "$label"
  wait $pid
  
  local exit_code=$(<"$status_file")
  rm -f "$status_file" "$stderr_log"

  # Analyze output
  analyze_output "$log" "$check_type"
  echo ""
  
  # Display output with smart formatting
  display_output "$log" "$check_type"

  if [ "$exit_code" -ne 0 ]; then
    echo -e "\n${red}ðŸ’¥ ${label} FAILED (exit code: $exit_code)${clear}"
    echo -e "${yellow}ðŸ” Check the output above for details${clear}"
    return $exit_code
  fi

  echo -e "\n${green}âœ… ${label} PASSED${clear}"
  return 0
}

# Store start time for total duration
SCRIPT_START=$(date +%s)

# Run checks with enhanced error handling
echo -e "${magenta}ðŸš€ Running pre-commit checks...${clear}\n"

CONTINUE_ON_FAILURE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --continue-on-failure)
      CONTINUE_ON_FAILURE=true
      shift
      ;;
    *)
      shift
      ;;
  esac
done

# Run checks
if ! run_with_progress "i18n Translation Check" "i18n:check" "i18n"; then
  if [ "$CONTINUE_ON_FAILURE" = false ]; then
    echo -e "\n${red}ðŸ›‘ Stopping due to i18n check failure${clear}"
    exit 1
  fi
fi

if ! run_with_progress "TypeScript Type Check" "types" "types"; then
  if [ "$CONTINUE_ON_FAILURE" = false ]; then
    echo -e "\n${red}ðŸ›‘ Stopping due to type check failure${clear}"
    exit 1
  fi
fi

if ! run_with_progress "ESLint Code Quality Check" "lint" "lint"; then
  if [ "$CONTINUE_ON_FAILURE" = false ]; then
    echo -e "\n${red}ðŸ›‘ Stopping due to lint check failure${clear}"
    exit 1
  fi
fi

# Calculate total execution time
SCRIPT_END=$(date +%s)
TOTAL_TIME=$((SCRIPT_END - SCRIPT_START))

# Cleanup
rm -f *_output.log

# Enhanced final summary
echo -e "\n${cyan}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${clear}"
echo -e "${blue}ðŸ“Š EXECUTION SUMMARY${clear}"
echo -e "${cyan}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${clear}"
echo -e "â±ï¸  Total execution time: ${TOTAL_TIME}s"
echo -e "âœ… Checks passed: ${green}${PASSED_CHECKS}/${TOTAL_CHECKS}${clear}"
echo -e "âŒ Checks failed: ${red}${FAILED_CHECKS}/${TOTAL_CHECKS}${clear}"
if [ "$WARNINGS" -gt 0 ]; then
  echo -e "âš ï¸  Total warnings: ${yellow}${WARNINGS}${clear}"
fi
echo -e "ðŸ Completed at: $(date)"

if [ "$FAILED_CHECKS" -eq 0 ]; then
  echo -e "\n${green}ðŸŽ‰ ALL CHECKS PASSED! READY TO COMMIT ðŸš€ðŸš€ðŸš€${clear}"
  echo -e "${green}   Your code is looking sharp! ðŸ’Ž${clear}"
  if [ "$WARNINGS" -gt 0 ]; then
    echo -e "${yellow}   Note: Consider addressing the ${WARNINGS} warning(s) above${clear}"
  fi
  exit 0
else
  echo -e "\n${red}ðŸ’¥ ${FAILED_CHECKS} CHECK(S) FAILED${clear}"
  echo -e "${red}   Please fix the issues above before committing${clear}"
  echo -e "${yellow}   ðŸ’¡ Tip: Use --continue-on-failure flag to see all issues at once${clear}"
  exit 1
fi