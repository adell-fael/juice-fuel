#!/bin/bash

PKG_MGR=pnpm

# Define colors
red='\033[1;31m'
green='\033[1;32m'
yellow='\033[1;33m'
cyan='\033[1;36m'
blue='\033[1;34m'
magenta='\033[1;35m'
clear='\033[0m'

# Global counters for summary
TOTAL_CHECKS=3
PASSED_CHECKS=0
FAILED_CHECKS=0
WARNINGS=0

# Enhanced progress bar with better status indicators
progress_bar() {
  local pid=$1
  local status_file=$2
  local label="$3"
  local delay=0.1
  local spin=('‚†ã' '‚†ô' '‚†π' '‚†∏' '‚†º' '‚†¥' '‚†¶' '‚†ß' '‚†á' '‚†è')
  local spin_idx=0
  local width=40
  local char="‚ñá"
  local start_time=$(date +%s)

  while kill -0 $pid 2>/dev/null; do
    local elapsed=$(( $(date +%s) - start_time ))
    # More realistic progress estimation based on typical task duration
    local progress=$(( (elapsed * 100 / 30) > 95 ? 95 : (elapsed * 100 / 30) ))
    local chars=$((progress * width / 100))

    printf "${cyan}\r[%s] ${yellow}%s${clear} [" "${spin[$spin_idx]}" "$label"
    for ((i = 0; i < chars; i++)); do printf "${green}$char${clear}"; done
    for ((i = chars; i < width; i++)); do printf "${blue}¬∑${clear}"; done
    printf "] %s%% (%ss)" "$progress" "$elapsed"
    sleep $delay
    ((spin_idx=(spin_idx + 1) % 10))
  done

  local elapsed_total=$(( $(date +%s) - start_time ))
  local exit_code=$(<"$status_file")

  if [ "$exit_code" -eq 0 ]; then
    printf "${green}\r[‚úì] %s [" "$label"
    for ((i = 0; i < width; i++)); do printf "$char"; done
    printf "] PASSED (%ss)${clear}\n"
    ((PASSED_CHECKS++))
  else
    printf "${red}\r[‚úó] %s [" "$label"
    for ((i = 0; i < width; i++)); do printf "‚ñà"; done
    printf "] FAILED (%ss)${clear}\n"
    ((FAILED_CHECKS++))
  fi
}

# Function to analyze and categorize output
analyze_output() {
  local log_file="$1"
  local check_type="$2"
  
  if [ ! -f "$log_file" ]; then
    echo -e "${red}Log file not found: $log_file${clear}"
    return 1
  fi

  local line_count=$(wc -l < "$log_file")
  local error_count=0
  local warning_count=0
  
  case "$check_type" in
    "i18n")
      # Look for actual error patterns, exclude success messages
      error_count=$(grep -i "error" "$log_file" | grep -v -i "no.*error\|0.*error" | wc -l)
      # Count actual missing/invalid items (numbers > 0)
      local missing_count=$(grep -E "[0-9]+ missing keys?" "$log_file" | grep -v "0 missing" | wc -l)
      local invalid_count=$(grep -E "[0-9]+ invalid translations?" "$log_file" | grep -v "0 invalid" | wc -l)
      error_count=$((error_count + missing_count + invalid_count))
      warning_count=$(grep -i "warning\|deprecated" "$log_file" | wc -l)
      ;;
    "types")
      error_count=$(grep -i "error\|TS[0-9]\+:" "$log_file" | wc -l)
      warning_count=$(grep -i "warning" "$log_file" | wc -l)
      ;;
    "lint")
      error_count=$(grep -i "error" "$log_file" | wc -l)
      warning_count=$(grep -i "warning" "$log_file" | wc -l)
      ;;
  esac

  # Check for explicit success indicators
  local success_indicators=0
  case "$check_type" in
    "i18n")
      success_indicators=$(grep -i "no missing keys\|no invalid translations\|done in" "$log_file" | wc -l)
      ;;
  esac

  if [ "$line_count" -eq 0 ]; then
    echo -e "  ${green}‚ú® Clean output - no issues detected${clear}"
  elif [ "$success_indicators" -gt 0 ] && [ "$error_count" -eq 0 ]; then
    echo -e "  ${green}‚ú® All checks passed - no issues found${clear}"
  elif [ "$error_count" -gt 0 ]; then
    echo -e "  ${red}üö® ${error_count} error(s) found${clear}"
    if [ "$warning_count" -gt 0 ]; then
      echo -e "  ${yellow}‚ö†Ô∏è  ${warning_count} warning(s) found${clear}"
      ((WARNINGS+=warning_count))
    fi
  elif [ "$warning_count" -gt 0 ]; then
    echo -e "  ${yellow}‚ö†Ô∏è  ${warning_count} warning(s) found${clear}"
    ((WARNINGS+=warning_count))
  else
    echo -e "  ${blue}üìù ${line_count} lines of output (review recommended)${clear}"
  fi
}

# Enhanced output display with smart truncation
display_output() {
  local log_file="$1"
  local check_type="$2"
  local max_lines=20
  
  if [ ! -f "$log_file" ] || [ ! -s "$log_file" ]; then
    echo -e "  ${green}‚ú® No output (clean run)${clear}"
    return 0
  fi

  local total_lines=$(wc -l < "$log_file")
  
  echo -e "  ${cyan}üìã Output Preview:${clear}"
  
  if [ "$total_lines" -le "$max_lines" ]; then
    # Show all lines if output is short
    sed 's/^/    /' "$log_file"
  else
    # Show first 10 and last 10 lines with separator
    echo -e "    ${blue}--- First 10 lines ---${clear}"
    head -10 "$log_file" | sed 's/^/    /'
    echo -e "    ${blue}--- ... ($((total_lines - 20)) lines omitted) ... ---${clear}"
    echo -e "    ${blue}--- Last 10 lines ---${clear}"
    tail -10 "$log_file" | sed 's/^/    /'
  fi
  
  if [ "$total_lines" -gt "$max_lines" ]; then
    echo -e "  ${yellow}üí° Full output available in: $log_file${clear}"
  fi
}

# Banner with timestamp
echo -e "
${green}
     _       _          _____           _ 
    | |_   _(_) ___ ___|  ___|   _  ___| |
 _  | | | | | |/ __/ _ \ |_ | | | |/ _ \ |
| |_| | |_| | | (_|  __/  _|| |_| |  __/ |
 \___/ \__,_|_|\___\___|_|   \__,_|\___|_|

${clear}
"

echo -e "Let's hope you are not ${red}DUMB${clear}!"
echo -e "${yellow}Using package manager: ${cyan}${PKG_MGR}${clear}"
echo -e "${blue}Started at: $(date)${clear}\n"

# Enhanced run function with better error handling and output analysis
run_with_progress() {
  local label="$1"
  local script="$2"
  local check_type="$3"
  local log="${script}_output.log"
  local status_file="${script}_status.tmp"
  local stderr_log="${script}_stderr.log"

  echo -e "${cyan}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${clear}"
  echo -e "${yellow}üîÑ Starting: ${label}${clear}"
  
  # Check if the script exists in package.json
  if ! $PKG_MGR run --silent $script --help >/dev/null 2>&1; then
    echo -e "${red}‚ùå Script '$script' not found in package.json${clear}"
    echo -e "${yellow}üí° Available scripts:${clear}"
    $PKG_MGR run 2>/dev/null | grep -E "^  [a-zA-Z]" | head -5
    ((FAILED_CHECKS++))
    return 1
  fi

  (
    # Capture both stdout and stderr separately
    $PKG_MGR run $script > "$log" 2> "$stderr_log"
    local cmd_exit=$?
    
    # Combine stderr into main log if there are errors
    if [ -s "$stderr_log" ]; then
      echo -e "\n--- STDERR ---" >> "$log"
      cat "$stderr_log" >> "$log"
    fi
    
    echo $cmd_exit > "$status_file"
  ) &
  
  local pid=$!
  progress_bar $pid "$status_file" "$label"
  wait $pid
  
  local exit_code=$(<"$status_file")
  rm -f "$status_file" "$stderr_log"

  # Analyze output
  analyze_output "$log" "$check_type"
  echo ""
  
  # Display output with smart formatting
  display_output "$log" "$check_type"

  if [ "$exit_code" -ne 0 ]; then
    echo -e "\n${red}üí• ${label} FAILED (exit code: $exit_code)${clear}"
    echo -e "${yellow}üîç Check the output above for details${clear}"
    return $exit_code
  fi

  echo -e "\n${green}‚úÖ ${label} PASSED${clear}"
  return 0
}

# Store start time for total duration
SCRIPT_START=$(date +%s)

# Run checks with enhanced error handling
echo -e "${magenta}üöÄ Running pre-commit checks...${clear}\n"

CONTINUE_ON_FAILURE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --continue-on-failure)
      CONTINUE_ON_FAILURE=true
      shift
      ;;
    *)
      shift
      ;;
  esac
done

# Run checks
if ! run_with_progress "i18n Translation Check" "i18n:check" "i18n"; then
  if [ "$CONTINUE_ON_FAILURE" = false ]; then
    echo -e "\n${red}üõë Stopping due to i18n check failure${clear}"
    exit 1
  fi
fi

if ! run_with_progress "TypeScript Type Check" "types" "types"; then
  if [ "$CONTINUE_ON_FAILURE" = false ]; then
    echo -e "\n${red}üõë Stopping due to type check failure${clear}"
    exit 1
  fi
fi

if ! run_with_progress "ESLint Code Quality Check" "lint" "lint"; then
  if [ "$CONTINUE_ON_FAILURE" = false ]; then
    echo -e "\n${red}üõë Stopping due to lint check failure${clear}"
    exit 1
  fi
fi

# Calculate total execution time
SCRIPT_END=$(date +%s)
TOTAL_TIME=$((SCRIPT_END - SCRIPT_START))

# Cleanup
rm -f *_output.log

# Enhanced final summary
echo -e "\n${cyan}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${clear}"
echo -e "${blue}üìä EXECUTION SUMMARY${clear}"
echo -e "${cyan}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${clear}"
echo -e "‚è±Ô∏è  Total execution time: ${TOTAL_TIME}s"
echo -e "‚úÖ Checks passed: ${green}${PASSED_CHECKS}/${TOTAL_CHECKS}${clear}"
echo -e "‚ùå Checks failed: ${red}${FAILED_CHECKS}/${TOTAL_CHECKS}${clear}"
if [ "$WARNINGS" -gt 0 ]; then
  echo -e "‚ö†Ô∏è  Total warnings: ${yellow}${WARNINGS}${clear}"
fi
echo -e "üèÅ Completed at: $(date)"

if [ "$FAILED_CHECKS" -eq 0 ]; then
  echo -e "\n${green}üéâ ALL CHECKS PASSED! READY TO COMMIT üöÄüöÄüöÄ${clear}"
  echo -e "${green}   Your code is looking sharp! üíé${clear}"
  if [ "$WARNINGS" -gt 0 ]; then
    echo -e "${yellow}   Note: Consider addressing the ${WARNINGS} warning(s) above${clear}"
  fi
  exit 0
else
  echo -e "\n${red}üí• ${FAILED_CHECKS} CHECK(S) FAILED${clear}"
  echo -e "${red}   Please fix the issues above before committing${clear}"
  echo -e "${yellow}   üí° Tip: Use --continue-on-failure flag to see all issues at once${clear}"
  exit 1
fi